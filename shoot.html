<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#39ff14', // Неоновый зеленый
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        #game-wrapper {
            font-family: 'Press Start 2P', monospace;
            touch-action: manipulation;
            overscroll-behavior: none;
            color: #39ff14;
            background-color: black;
        }
        
        #game-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #game-container {
            background-color: black !important;
            border: 2px solid #39ff14 !important;
        }
        
        .pixel-button {
            image-rendering: pixelated;
            font-family: 'Press Start 2P', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            background-color: black !important;
            color: #39ff14 !important;
            border: 2px solid #39ff14 !important;
        }
        
        .pixel-button:hover {
            background-color: #39ff14 !important;
            color: black !important;
        }
        
        .game-text {
            color: #39ff14 !important;
        }
        
        .game-screen {
            background-color: rgba(0, 0, 0, 0.8) !important;
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="game-wrapper" class="container mx-auto px-4 py-8 flex flex-col items-center">
        
        
        <div id="game-container" class="relative bg-gray-100 w-full max-w-lg border-4 border-gray-800 dark:border-gray-600 rounded-lg overflow-hidden shadow-lg">
            <canvas id="game-canvas" class="w-full"></canvas>
            
            <div id="game-ui" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                <div id="score-display" class="absolute top-4 left-4 game-text text-lg font-bold bg-black bg-opacity-70 px-2 py-1 rounded border border-[#39ff14]">Score: 0</div>
                <div id="health-display" class="absolute top-4 right-4 game-text text-lg font-bold bg-black bg-opacity-70 px-2 py-1 rounded border border-[#39ff14]">♥♥♥</div>
            </div>
            
            <div id="game-over" class="game-screen absolute inset-0 flex flex-col items-center justify-center hidden">
                <div class="game-text text-2xl font-bold mb-4">GAME OVER</div>
                <div id="final-score" class="game-text text-xl mb-6">Score: 0</div>
                <button id="restart-button" class="pixel-button py-2 px-4 rounded pointer-events-auto">
                    RESTART
                </button>
            </div>
            
            <div id="start-screen" class="game-screen absolute inset-0 flex flex-col items-center justify-center">
                <div class="game-text text-2xl font-bold mb-4">ПЧЕЛЫ ПРОТИВ ЛОТОСОВ</div>
                <div class="game-text text-base mb-6 text-center px-4">
                    <p class="mb-2">ОТПРАВЛЯЙТЕ ПЧЕЛ НА АТАКУ ЛОТОСОВ!</p>
                    <p class="text-sm mt-4">УПРАВЛЕНИЕ: СТРЕЛКИ/WASD - ДВИЖЕНИЕ, ПРОБЕЛ - АТАКА</p>
                    <p class="text-sm mt-2">НА МОБИЛЬНЫХ: КАСАЙТЕСЬ ЭКРАНА</p>
                </div>
                <button id="start-button" class="pixel-button py-2 px-4 rounded pointer-events-auto">
                    СТАРТ
                </button>
            </div>
            
            <div id="mobile-controls" class="absolute bottom-0 left-0 right-0 h-24 flex items-center justify-between px-4 pointer-events-none hidden">
                <div id="mobile-move" class="w-32 h-24 bg-black bg-opacity-20 rounded-t pointer-events-auto"></div>
                <div id="mobile-shoot" class="w-32 h-24 bg-black bg-opacity-20 rounded-t pointer-events-auto"></div>
            </div>
        </div>
        
        <div class="mt-4 text-center">
            <p class="text-sm">ИСПОЛЬЗУЙТЕ СТРЕЛКИ ИЛИ WASD ДЛЯ ДВИЖЕНИЯ, ПРОБЕЛ ДЛЯ АТАКИ</p>
        </div>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game initialization
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score-display');
            const healthDisplay = document.getElementById('health-display');
            const gameOverScreen = document.getElementById('game-over');
            const finalScoreDisplay = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            const mobileControls = document.getElementById('mobile-controls');
            const mobileMove = document.getElementById('mobile-move');
            const mobileShoot = document.getElementById('mobile-shoot');

            // Game settings
            const GAME_WIDTH = 320;
            const GAME_HEIGHT = 480;
            const PLAYER_SIZE = 24;
            const ENEMY_SIZE = 16;
            const BULLET_SIZE = 8;
            const PLAYER_SPEED = 5;
            const ENEMY_SPEED = 1.5;
            const BULLET_SPEED = 8;
            const ENEMY_SPAWN_RATE = 60; // Frames between enemy spawns
            
            // Game state
            let player = { x: GAME_WIDTH / 2 - PLAYER_SIZE / 2, y: GAME_HEIGHT - PLAYER_SIZE - 10, width: PLAYER_SIZE, height: PLAYER_SIZE, health: 3 };
            let bullets = [];
            let enemies = [];
            let score = 0;
            let gameOver = false;
            let gameActive = false;
            let enemySpawnCounter = 0;
            let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // Colors - неоново-зеленая cyber тема
            const COLORS = {
                background: '#000000', // Черный фон
                player: '#39ff14', // Неоново-зеленый для улья
                playerOutline: '#116600', // Темно-зеленый для контуров улья
                enemy: '#ff39c3', // Неоново-розовый для цветов лотоса
                enemyOutline: '#990066', // Темно-розовый для контуров лотоса
                bullet: '#39ff14', // Неоново-зеленый для пчел
                bulletOutline: '#116600', // Темно-зеленый для контуров пчел
                stars: ['#39ff14', '#1aaa00', '#00ff88'] // Оттенки неона
            };
            
            // Generate stars for background
            const stars = Array(100).fill().map(() => ({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                size: Math.random() > 0.8 ? 2 : 1,
                color: COLORS.stars[Math.floor(Math.random() * COLORS.stars.length)],
                speed: Math.random() * 0.5 + 0.1
            }));
            
            // Input handling
            const keys = {
                left: false,
                right: false,
                up: false,
                down: false,
                shoot: false
            };
            
            // Set canvas size based on container
            function resizeCanvas() {
                const container = canvas.parentElement;
                const containerWidth = container.clientWidth;
                const scale = containerWidth / GAME_WIDTH;
                
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                canvas.style.height = `${GAME_HEIGHT * scale}px`;
                
                // Show mobile controls on small screens
                if (isMobile) {
                    mobileControls.classList.remove('hidden');
                }
            }
            
            // Initialize game
            function init() {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            keys.left = true;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            keys.right = true;
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            keys.up = true;
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            keys.down = true;
                            break;
                        case ' ':
                            keys.shoot = true;
                            break;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            keys.left = false;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            keys.right = false;
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            keys.up = false;
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            keys.down = false;
                            break;
                        case ' ':
                            keys.shoot = false;
                            break;
                    }
                });
                
                // Mobile controls
                if (isMobile) {
                    let moveTouch = null;
                    let shootInterval = null;
                    
                    mobileMove.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        moveTouch = e.touches[0];
                    });
                    
                    mobileMove.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        if (moveTouch && e.touches[0]) {
                            const dx = e.touches[0].clientX - moveTouch.clientX;
                            if (dx < -10) keys.left = true;
                            else if (dx > 10) keys.right = true;
                            else { keys.left = false; keys.right = false; }
                            
                            const dy = e.touches[0].clientY - moveTouch.clientY;
                            if (dy < -10) keys.up = true;
                            else if (dy > 10) keys.down = true;
                            else { keys.up = false; keys.down = false; }
                        }
                    });
                    
                    mobileMove.addEventListener('touchend', () => {
                        moveTouch = null;
                        keys.left = false;
                        keys.right = false;
                        keys.up = false;
                        keys.down = false;
                    });
                    
                    mobileShoot.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        keys.shoot = true;
                        if (!shootInterval) {
                            shootInterval = setInterval(() => {
                                keys.shoot = true;
                            }, 150);
                        }
                    });
                    
                    mobileShoot.addEventListener('touchend', () => {
                        if (shootInterval) {
                            clearInterval(shootInterval);
                            shootInterval = null;
                        }
                    });
                    
                    // Prevent zoom on double tap
                    canvas.addEventListener('touchstart', (e) => {
                        if (e.touches.length > 1) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
                
                // Start game button
                startButton.addEventListener('click', startGame);
                
                // Restart button
                restartButton.addEventListener('click', () => {
                    gameOverScreen.classList.add('hidden');
                    resetGame();
                    startGame();
                });
                
                // Initial render
                render();
            }
            
            function startGame() {
                startScreen.classList.add('hidden');
                gameActive = true;
                gameLoop();
            }
            
            function resetGame() {
                player = { x: GAME_WIDTH / 2 - PLAYER_SIZE / 2, y: GAME_HEIGHT - PLAYER_SIZE - 10, width: PLAYER_SIZE, height: PLAYER_SIZE, health: 3 };
                bullets = [];
                enemies = [];
                score = 0;
                gameOver = false;
                enemySpawnCounter = 0;
                updateUI();
            }
            
            function updateUI() {
                scoreDisplay.textContent = `Score: ${score}`;
                healthDisplay.textContent = '♥'.repeat(player.health);
                finalScoreDisplay.textContent = `Final Score: ${score}`;
            }
            
            // Game loop
            function gameLoop() {
                if (!gameActive) return;
                
                update();
                render();
                
                if (!gameOver) {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            // Update game state
            function update() {
                if (gameOver) return;
                
                // Update player position
                if (keys.left) player.x -= PLAYER_SPEED;
                if (keys.right) player.x += PLAYER_SPEED;
                if (keys.up) player.y -= PLAYER_SPEED;
                if (keys.down) player.y += PLAYER_SPEED;
                
                // Keep player within game bounds
                player.x = Math.max(0, Math.min(GAME_WIDTH - player.width, player.x));
                player.y = Math.max(GAME_HEIGHT / 2, Math.min(GAME_HEIGHT - player.height, player.y));
                
                // Create bullets when shooting
                if (keys.shoot) {
                    keys.shoot = false; // Reset to prevent rapid fire
                    bullets.push({
                        x: player.x + player.width / 2 - BULLET_SIZE / 2,
                        y: player.y - BULLET_SIZE,
                        width: BULLET_SIZE,
                        height: BULLET_SIZE
                    });
                }
                
                // Update bullets
                bullets.forEach((bullet, i) => {
                    bullet.y -= BULLET_SPEED;
                    
                    // Remove bullets that go off screen
                    if (bullet.y + bullet.height < 0) {
                        bullets.splice(i, 1);
                    }
                });
                
                // Spawn enemies
                enemySpawnCounter++;
                if (enemySpawnCounter >= ENEMY_SPAWN_RATE) {
                    enemySpawnCounter = 0;
                    enemies.push({
                        x: Math.random() * (GAME_WIDTH - ENEMY_SIZE),
                        y: -ENEMY_SIZE,
                        width: ENEMY_SIZE,
                        height: ENEMY_SIZE,
                        speed: ENEMY_SPEED * (1 + score / 1000) // Enemies get faster as score increases
                    });
                }
                
                // Update enemies
                enemies.forEach((enemy, i) => {
                    enemy.y += enemy.speed;
                    
                    // Enemy hit player
                    if (checkCollision(enemy, player)) {
                        enemies.splice(i, 1);
                        player.health--;
                        updateUI();
                        
                        if (player.health <= 0) {
                            gameOver = true;
                            gameActive = false;
                            gameOverScreen.classList.remove('hidden');
                        }
                    }
                    
                    // Enemy went off screen
                    if (enemy.y > GAME_HEIGHT) {
                        enemies.splice(i, 1);
                    }
                });
                
                // Check for bullet-enemy collisions
                bullets.forEach((bullet, bi) => {
                    enemies.forEach((enemy, ei) => {
                        if (checkCollision(bullet, enemy)) {
                            // Remove bullet and enemy
                            bullets.splice(bi, 1);
                            enemies.splice(ei, 1);
                            
                            // Increase score
                            score += 10;
                            updateUI();
                        }
                    });
                });
                
                // Update star positions (parallax background)
                stars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > GAME_HEIGHT) {
                        star.y = 0;
                        star.x = Math.random() * GAME_WIDTH;
                    }
                });
            }
            
            // Check if two objects are colliding
            function checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            // Render game
            function render() {
                // Clear canvas
                ctx.fillStyle = COLORS.background;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                // Draw stars (background)
                stars.forEach(star => {
                    ctx.fillStyle = star.color;
                    ctx.fillRect(star.x, star.y, star.size, star.size);
                });
                
                // Draw player (улей)
                drawPixelArt(ctx, player.x, player.y, [
                    '   XXXX   ',
                    ' XXXXXXXX ',
                    'XXXXXXXXXX',
                    'X XXXXXX X',
                    'X X XX X X',
                    'X XXXXXX X',
                    'XXXXXXXXXX',
                    ' XXXXXXXX '
                ], COLORS.player, COLORS.playerOutline);
                
                // Draw bullets (пчелы)
                bullets.forEach(bullet => {
                    drawPixelArt(ctx, bullet.x, bullet.y, [
                        ' XX ',
                        'X  X',
                        'XXXX',
                        ' XX '
                    ], COLORS.bullet, COLORS.bulletOutline);
                });
                
                // Draw enemies (цветы-лотосы)
                enemies.forEach(enemy => {
                    drawPixelArt(ctx, enemy.x, enemy.y, [
                        '  XX  ',
                        ' XXXX ',
                        'XXXXXX',
                        'XXXXXX',
                        ' XXXX ',
                        '  XX  '
                    ], COLORS.enemy, COLORS.enemyOutline);
                });
            }
            
            // Draw pixel art from pattern
            function drawPixelArt(ctx, x, y, pattern, fillColor, outlineColor) {
                const pixelSize = pattern[0].length > 0 ? Math.ceil(PLAYER_SIZE / pattern[0].length) : 1;
                
                pattern.forEach((row, rowIndex) => {
                    for (let colIndex = 0; colIndex < row.length; colIndex++) {
                        if (row[colIndex] === 'X') {
                            ctx.fillStyle = fillColor;
                            ctx.fillRect(
                                x + colIndex * pixelSize,
                                y + rowIndex * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                            
                            // Add outline
                            ctx.fillStyle = outlineColor;
                            
                            // Check neighboring pixels for outline
                            const hasLeft = colIndex > 0 && row[colIndex - 1] !== 'X';
                            const hasRight = colIndex < row.length - 1 && row[colIndex + 1] !== 'X';
                            const hasTop = rowIndex > 0 && pattern[rowIndex - 1][colIndex] !== 'X';
                            const hasBottom = rowIndex < pattern.length - 1 && pattern[rowIndex + 1][colIndex] !== 'X';
                            
                            // Draw outlines where needed
                            if (hasLeft) ctx.fillRect(x + colIndex * pixelSize, y + rowIndex * pixelSize, 1, pixelSize);
                            if (hasRight) ctx.fillRect(x + (colIndex + 1) * pixelSize - 1, y + rowIndex * pixelSize, 1, pixelSize);
                            if (hasTop) ctx.fillRect(x + colIndex * pixelSize, y + rowIndex * pixelSize, pixelSize, 1);
                            if (hasBottom) ctx.fillRect(x + colIndex * pixelSize, y + (rowIndex + 1) * pixelSize - 1, pixelSize, 1);
                        }
                    }
                });
            }
            
            // Initialize the game
            init();
        });
    </script>
</body>
</html>